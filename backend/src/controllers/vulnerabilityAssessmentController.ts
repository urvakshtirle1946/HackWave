import { Request, Response } from 'express';
import vulnerabilityDataService from '../services/vulnerabilityDataService';
import { ScenarioRequest } from '../types/vulnerabilityAssessment';

class VulnerabilityAssessmentController {
  // Get current vulnerability assessment
  public async getVulnerabilityAssessment(req: Request, res: Response) {
    try {
      const assessment = vulnerabilityDataService.getVulnerabilityAssessment();
      res.json({
        success: true,
        data: assessment,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch vulnerability assessment',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Get real-time updates
  public async getRealTimeUpdates(req: Request, res: Response) {
    try {
      const assessment = vulnerabilityDataService.getRealTimeUpdates();
      res.json({
        success: true,
        data: assessment,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch real-time updates',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Apply disruption scenario
  public async applyDisruptionScenario(req: Request, res: Response) {
    try {
      const { scenarioType, severity, affectedLanes, duration }: ScenarioRequest = req.body;
      
      if (!scenarioType || !severity) {
        return res.status(400).json({
          success: false,
          error: 'Missing required parameters',
          message: 'scenarioType and severity are required'
        });
      }

      const scenario = vulnerabilityDataService.applyDisruptionScenario(
        scenarioType,
        severity,
        affectedLanes
      );

      const updatedAssessment = vulnerabilityDataService.getVulnerabilityAssessment();

      res.json({
        success: true,
        data: {
          scenario,
          updatedAssessment,
          message: `Disruption scenario applied successfully`
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to apply disruption scenario',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Clear disruption scenario
  public async clearDisruption(req: Request, res: Response) {
    try {
      const { scenarioId } = req.params;
      
      if (!scenarioId) {
        return res.status(400).json({
          success: false,
          error: 'Missing scenario ID',
          message: 'scenarioId is required'
        });
      }

      const success = vulnerabilityDataService.clearDisruption(scenarioId);
      
      if (!success) {
        return res.status(404).json({
          success: false,
          error: 'Scenario not found',
          message: 'Disruption scenario not found'
        });
      }

      const updatedAssessment = vulnerabilityDataService.getVulnerabilityAssessment();

      res.json({
        success: true,
        data: {
          updatedAssessment,
          message: `Disruption scenario cleared successfully`
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to clear disruption scenario',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Get available scenario types
  public async getScenarioTypes(req: Request, res: Response) {
    try {
      const scenarioTypes = [
        {
          id: 'port_closure',
          name: 'Port Closure',
          description: 'Simulate port shutdown or congestion',
          severityLevels: ['low', 'medium', 'high', 'critical']
        },
        {
          id: 'carrier_strike',
          name: 'Carrier Strike',
          description: 'Simulate carrier service disruption',
          severityLevels: ['low', 'medium', 'high', 'critical']
        },
        {
          id: 'fuel_spike',
          name: 'Fuel Price Spike',
          description: 'Simulate sudden fuel cost increase',
          severityLevels: ['low', 'medium', 'high', 'critical']
        },
        {
          id: 'weather_event',
          name: 'Weather Event',
          description: 'Simulate weather-related disruptions',
          severityLevels: ['low', 'medium', 'high', 'critical']
        },
        {
          id: 'border_delay',
          name: 'Border Delay',
          description: 'Simulate customs or border delays',
          severityLevels: ['low', 'medium', 'high', 'critical']
        }
      ];

      res.json({
        success: true,
        data: scenarioTypes,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch scenario types',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Get risk breakdown for a specific lane
  public async getLaneRiskBreakdown(req: Request, res: Response) {
    try {
      const { laneId } = req.params;
      
      if (!laneId) {
        return res.status(400).json({
          success: false,
          error: 'Missing lane ID',
          message: 'laneId is required'
        });
      }

      const assessment = vulnerabilityDataService.getVulnerabilityAssessment();
      const lane = assessment.lanes.find(l => l.id === laneId);
      
      if (!lane) {
        return res.status(404).json({
          success: false,
          error: 'Lane not found',
          message: 'Lane not found'
        });
      }

      res.json({
        success: true,
        data: {
          lane,
          riskBreakdown: lane.riskScore.breakdown,
          recommendations: assessment.recommendations.filter(r => r.laneId === laneId)
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch lane risk breakdown',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // Get system health and performance metrics
  public async getSystemHealth(req: Request, res: Response) {
    try {
      const assessment = vulnerabilityDataService.getVulnerabilityAssessment();
      
      const healthMetrics = {
        totalLanes: assessment.summary.totalLanes,
        highRiskLanes: assessment.summary.highRiskLanes,
        activeDisruptions: assessment.summary.activeDisruptions,
        averageRiskScore: assessment.summary.averageRiskScore,
        riskDistribution: {
          green: assessment.lanes.filter(l => l.riskScore.status === 'green').length,
          amber: assessment.lanes.filter(l => l.riskScore.status === 'amber').length,
          red: assessment.lanes.filter(l => l.riskScore.status === 'red').length
        },
        modeDistribution: {
          sea: assessment.lanes.filter(l => l.mode === 'sea').length,
          air: assessment.lanes.filter(l => l.mode === 'air').length,
          road: assessment.lanes.filter(l => l.mode === 'road').length,
          rail: assessment.lanes.filter(l => l.mode === 'rail').length
        },
        lastUpdated: assessment.timestamp
      };

      res.json({
        success: true,
        data: healthMetrics,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch system health',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
}

export default new VulnerabilityAssessmentController();
