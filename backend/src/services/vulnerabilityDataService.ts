import {
  LaneData,
  TransportationMetrics,
  RiskScore,
  DisruptionScenario,
  Recommendation,
  VulnerabilityAssessment
} from '../types/vulnerabilityAssessment';

class VulnerabilityDataService {
  private mockLanes: LaneData[] = [
    {
      id: 'lane-001',
      origin: 'Mumbai (Nhava Sheva)',
      destination: 'Hamburg',
      mode: 'sea',
      carrier: 'Maersk Line',
      metrics: {
        onTimePercentage: 82,
        dwellTimeHours: 18,
        costPerUnit: 1250,
        congestionLevel: 0.3,
        fuelEfficiency: 0.85,
        carrierReliability: 0.88
      },
      riskScore: this.calculateRiskScore({
        onTimePercentage: 82,
        dwellTimeHours: 18,
        costPerUnit: 1250,
        congestionLevel: 0.3,
        fuelEfficiency: 0.85,
        carrierReliability: 0.88
      }),
      lastUpdated: new Date().toISOString()
    },
    {
      id: 'lane-002',
      origin: 'Shanghai',
      destination: 'Los Angeles',
      mode: 'sea',
      carrier: 'COSCO Shipping',
      metrics: {
        onTimePercentage: 78,
        dwellTimeHours: 24,
        costPerUnit: 1350,
        congestionLevel: 0.45,
        fuelEfficiency: 0.82,
        carrierReliability: 0.85
      },
      riskScore: this.calculateRiskScore({
        onTimePercentage: 78,
        dwellTimeHours: 24,
        costPerUnit: 1350,
        congestionLevel: 0.45,
        fuelEfficiency: 0.82,
        carrierReliability: 0.85
      }),
      lastUpdated: new Date().toISOString()
    },
    {
      id: 'lane-003',
      origin: 'Dubai',
      destination: 'Rotterdam',
      mode: 'sea',
      carrier: 'MSC',
      metrics: {
        onTimePercentage: 89,
        dwellTimeHours: 12,
        costPerUnit: 1100,
        congestionLevel: 0.2,
        fuelEfficiency: 0.88,
        carrierReliability: 0.92
      },
      riskScore: this.calculateRiskScore({
        onTimePercentage: 89,
        dwellTimeHours: 12,
        costPerUnit: 1100,
        congestionLevel: 0.2,
        fuelEfficiency: 0.88,
        carrierReliability: 0.92
      }),
      lastUpdated: new Date().toISOString()
    },
    {
      id: 'lane-004',
      origin: 'Chicago',
      destination: 'Toronto',
      mode: 'rail',
      carrier: 'Canadian National',
      metrics: {
        onTimePercentage: 91,
        dwellTimeHours: 8,
        costPerUnit: 450,
        congestionLevel: 0.15,
        fuelEfficiency: 0.90,
        carrierReliability: 0.94
      },
      riskScore: this.calculateRiskScore({
        onTimePercentage: 91,
        dwellTimeHours: 8,
        costPerUnit: 450,
        congestionLevel: 0.15,
        fuelEfficiency: 0.90,
        carrierReliability: 0.94
      }),
      lastUpdated: new Date().toISOString()
    },
    {
      id: 'lane-005',
      origin: 'Frankfurt',
      destination: 'London',
      mode: 'air',
      carrier: 'Lufthansa Cargo',
      metrics: {
        onTimePercentage: 87,
        dwellTimeHours: 4,
        costPerUnit: 2800,
        congestionLevel: 0.25,
        fuelEfficiency: 0.75,
        carrierReliability: 0.89
      },
      riskScore: this.calculateRiskScore({
        onTimePercentage: 87,
        dwellTimeHours: 4,
        costPerUnit: 2800,
        congestionLevel: 0.25,
        fuelEfficiency: 0.75,
        carrierReliability: 0.89
      }),
      lastUpdated: new Date().toISOString()
    },
    {
      id: 'lane-006',
      origin: 'Mumbai',
      destination: 'Delhi',
      mode: 'road',
      carrier: 'Tata Motors Logistics',
      metrics: {
        onTimePercentage: 75,
        dwellTimeHours: 6,
        costPerUnit: 180,
        congestionLevel: 0.6,
        fuelEfficiency: 0.70,
        carrierReliability: 0.78
      },
      riskScore: this.calculateRiskScore({
        onTimePercentage: 75,
        dwellTimeHours: 6,
        costPerUnit: 180,
        congestionLevel: 0.6,
        fuelEfficiency: 0.70,
        carrierReliability: 0.78
      }),
      lastUpdated: new Date().toISOString()
    }
  ];

  private activeDisruptions: DisruptionScenario[] = [];
  private recommendations: Recommendation[] = [];

  private calculateRiskScore(metrics: TransportationMetrics): RiskScore {
    // Calculate risk based on multiple factors
    const operationalRisk = (100 - metrics.onTimePercentage) * 0.3 +
      (metrics.dwellTimeHours / 24) * 20 +
      (metrics.congestionLevel * 30);

    const economicRisk = (metrics.costPerUnit / 1000) * 15;

    const infrastructureRisk = (1 - metrics.fuelEfficiency) * 25 +
      (1 - metrics.carrierReliability) * 30;

    const weatherRisk = Math.random() * 20; // Simulated weather risk
    const geopoliticalRisk = Math.random() * 25; // Simulated geopolitical risk

    const overallRisk = Math.min(100,
      operationalRisk + economicRisk + infrastructureRisk + weatherRisk + geopoliticalRisk
    );

    let status: 'green' | 'amber' | 'red';
    if (overallRisk < 40) status = 'green';
    else if (overallRisk < 70) status = 'amber';
    else status = 'red';

    return {
      overall: Math.round(overallRisk),
      status,
      breakdown: {
        operational: Math.round(operationalRisk),
        geopolitical: Math.round(geopoliticalRisk),
        weather: Math.round(weatherRisk),
        economic: Math.round(economicRisk),
        infrastructure: Math.round(infrastructureRisk)
      }
    };
  }

  public getVulnerabilityAssessment(): VulnerabilityAssessment {
    return {
      timestamp: new Date().toISOString(),
      lanes: this.mockLanes,
      activeDisruptions: this.activeDisruptions,
      recommendations: this.recommendations,
      summary: {
        totalLanes: this.mockLanes.length,
        highRiskLanes: this.mockLanes.filter(lane => lane.riskScore.status === 'red').length,
        activeDisruptions: this.activeDisruptions.length,
        averageRiskScore: Math.round(
          this.mockLanes.reduce((sum, lane) => sum + lane.riskScore.overall, 0) / this.mockLanes.length
        )
      }
    };
  }

  public applyDisruptionScenario(scenarioType: string, severity: string, affectedLanes?: string[]): DisruptionScenario {
    const scenario: DisruptionScenario = {
      id: `disruption-${Date.now()}`,
      name: this.getScenarioName(scenarioType, severity),
      type: scenarioType as any,
      severity: severity as any,
      affectedLanes: affectedLanes || this.mockLanes.slice(0, 2).map(lane => lane.id),
      impact: this.calculateScenarioImpact(scenarioType, severity),
      duration: this.getScenarioDuration(severity)
    };

    this.activeDisruptions.push(scenario);

    // Update affected lanes with disruption impact
    this.updateLanesForDisruption(scenario);

    // Generate new recommendations
    this.generateRecommendations(scenario);

    return scenario;
  }

  private getScenarioName(type: string, severity: string): string {
    const names = {
      port_closure: `Port Closure - ${severity} severity`,
      carrier_strike: `Carrier Strike - ${severity} severity`,
      fuel_spike: `Fuel Price Spike - ${severity} severity`,
      weather_event: `Weather Event - ${severity} severity`,
      border_delay: `Border Delay - ${severity} severity`
    };
    return names[type as keyof typeof names] || `Unknown Scenario - ${severity}`;
  }

  private calculateScenarioImpact(type: string, severity: string) {
    const severityMultiplier = { low: 0.5, medium: 1, high: 1.5, critical: 2 };
    const multiplier = severityMultiplier[severity as keyof typeof severityMultiplier] || 1;

    const baseImpacts = {
      port_closure: { delayHours: 48, costIncrease: 0.15, reliabilityDecrease: 0.25 },
      carrier_strike: { delayHours: 72, costIncrease: 0.20, reliabilityDecrease: 0.30 },
      fuel_spike: { delayHours: 12, costIncrease: 0.25, reliabilityDecrease: 0.15 },
      weather_event: { delayHours: 24, costIncrease: 0.10, reliabilityDecrease: 0.20 },
      border_delay: { delayHours: 36, costIncrease: 0.08, reliabilityDecrease: 0.18 }
    };

    const base = baseImpacts[type as keyof typeof baseImpacts] || { delayHours: 24, costIncrease: 0.15, reliabilityDecrease: 0.20 };

    return {
      delayHours: Math.round(base.delayHours * multiplier),
      costIncrease: base.costIncrease * multiplier,
      reliabilityDecrease: base.reliabilityDecrease * multiplier
    };
  }

  private getScenarioDuration(severity: string): number {
    const durations = { low: 12, medium: 24, high: 48, critical: 72 };
    return durations[severity as keyof typeof durations] || 24;
  }

  private updateLanesForDisruption(scenario: DisruptionScenario) {
    scenario.affectedLanes.forEach(laneId => {
      const lane = this.mockLanes.find(l => l.id === laneId);
      if (lane) {
        // Update metrics based on disruption
        lane.metrics.dwellTimeHours += scenario.impact.delayHours;
        lane.metrics.costPerUnit *= (1 + scenario.impact.costIncrease);
        lane.metrics.onTimePercentage *= (1 - scenario.impact.reliabilityDecrease);

        // Recalculate risk score
        lane.riskScore = this.calculateRiskScore(lane.metrics);
        lane.lastUpdated = new Date().toISOString();
      }
    });
  }

  private generateRecommendations(scenario: DisruptionScenario) {
    scenario.affectedLanes.forEach(laneId => {
      const lane = this.mockLanes.find(l => l.id === laneId);
      if (lane) {
        const recommendation: Recommendation = {
          id: `rec-${Date.now()}-${laneId}`,
          laneId,
          type: this.getRecommendationType(scenario.type),
          description: this.getRecommendationDescription(scenario.type, lane),
          impact: this.calculateRecommendationImpact(scenario, lane),
          priority: this.getRecommendationPriority(scenario.severity),
          implementationTime: this.getImplementationTime(scenario.type)
        };

        this.recommendations.push(recommendation);
      }
    });
  }

  private getRecommendationType(scenarioType: string): Recommendation['type'] {
    const typeMap = {
      port_closure: 'reroute',
      carrier_strike: 'carrier_switch',
      fuel_spike: 'expedite',
      weather_event: 'reroute',
      border_delay: 'expedite'
    };
    return (typeMap[scenarioType as keyof typeof typeMap] ?? 'reroute') as Recommendation['type'];
  }

  private getRecommendationDescription(scenarioType: string, lane: LaneData): string {
    const descriptions = {
      port_closure: `Reroute via alternative port to avoid ${lane.origin} closure`,
      carrier_strike: `Switch to alternative carrier to maintain service level`,
      fuel_spike: `Expedite shipment to minimize fuel cost impact`,
      weather_event: `Reroute to avoid weather-affected areas`,
      border_delay: `Expedite customs clearance to reduce delays`
    };
    return descriptions[scenarioType as keyof typeof descriptions] || 'Apply mitigation strategy';
  }

  private calculateRecommendationImpact(scenario: DisruptionScenario, lane: LaneData) {
    const baseRiskReduction = 15;
    const baseCostChange = -0.05;
    const baseTimeChange = -scenario.impact.delayHours * 0.3;

    return {
      riskReduction: baseRiskReduction + (scenario.severity === 'critical' ? 10 : 0),
      costChange: baseCostChange + (scenario.severity === 'high' ? 0.02 : 0),
      timeChange: baseTimeChange
    };
  }

  private getRecommendationPriority(severity: string): Recommendation['priority'] {
    const priorityMap = { low: 'low', medium: 'medium', high: 'high', critical: 'critical' };
    return (priorityMap[severity as keyof typeof priorityMap] as Recommendation['priority']) || 'medium';
  }

  private getImplementationTime(scenarioType: string): number {
    const times = {
      port_closure: 6,
      carrier_strike: 12,
      fuel_spike: 2,
      weather_event: 4,
      border_delay: 3
    };
    return times[scenarioType as keyof typeof times] || 6;
  }

  public clearDisruption(scenarioId: string): boolean {
    const index = this.activeDisruptions.findIndex(d => d.id === scenarioId);
    if (index > -1) {
      this.activeDisruptions.splice(index, 1);
      return true;
    }
    return false;
  }

  public getRealTimeUpdates(): VulnerabilityAssessment {
    // Simulate real-time updates by slightly modifying some metrics
    this.mockLanes.forEach(lane => {
      // Small random variations to simulate real-time changes
      lane.metrics.onTimePercentage += (Math.random() - 0.5) * 2;
      lane.metrics.dwellTimeHours += (Math.random() - 0.5) * 1;
      lane.metrics.costPerUnit += (Math.random() - 0.5) * 10;

      // Ensure values stay within reasonable bounds
      lane.metrics.onTimePercentage = Math.max(0, Math.min(100, lane.metrics.onTimePercentage));
      lane.metrics.dwellTimeHours = Math.max(0, lane.metrics.dwellTimeHours);
      lane.metrics.costPerUnit = Math.max(100, lane.metrics.costPerUnit);

      // Recalculate risk score
      lane.riskScore = this.calculateRiskScore(lane.metrics);
      lane.lastUpdated = new Date().toISOString();
    });

    return this.getVulnerabilityAssessment();
  }
}

export default new VulnerabilityDataService();
